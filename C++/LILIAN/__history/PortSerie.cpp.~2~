//---------------------------------------------------------------------------

#pragma hdrstop

#include "PortSerie.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)

//---------------------------------------------------------------------------

#pragma hdrstop
#include <windows.h>
#include <stdlib.h>
#include <conio.h>
#include <tchar.h>f
#include <stdio.h>

#include <string>
//---------------------------------------------------------------------------
#pragma package(smart_init)

// initialisation
PortSerie::PortSerie()   //Constructeur
{
	ignoreData = true;
}
//------------------------------------------------------------------------------------//

PortSerie::~PortSerie()  //destructeur
{
}

//------------------------------------------------------------------------------------//
void PortSerie::fermerport()   //Methode pour fermer le port
{
	CloseHandle(hCom); // fermeture du port série
}

//------------------------------------------------------------------------------------//
// connexion au port COM1
int PortSerie::ouvrirport()
{
	DCB dcb;
	BOOL fSuccess;
	// pcComPort : Port com correspondant
	char * pcCommPort = "COM6";


   hCom = CreateFile( pcCommPort,   //nom du port
					  GENERIC_READ | GENERIC_WRITE,  //lecture et ecriture
					  0,      // pas de partage
					  NULL,   //  Aucune sécurité
					  OPEN_EXISTING, // ouvre le port existant uniquement
					  0,      //  E/S non superposé
					  NULL ); //  Null pour les periphérique de communnication

   if (hCom == INVALID_HANDLE_VALUE)
   {

	   return (1);
   }

   //  Structure DCB (permet de controler :débit de bauds, nb de bit de démarrage/d'arrêt, format de données)
   SecureZeroMemory(&dcb, sizeof(DCB));
   dcb.DCBlength = sizeof(DCB);

   // recupération des paramètres actuels du port
   fSuccess = GetCommState(hCom, &dcb);

   if (!fSuccess)
   {

	  printf ("GetCommState failed with error %d.", GetLastError());
	  return (2);
   }

   // On définit les valeurs (debit de bauds, taille des octets, nb de bits de démarage et d'arrêt)
   dcb.BaudRate = CBR_9600;     //  baudRate = 9600
   dcb.ByteSize = 8;             //  ByteSize
   dcb.Parity   = NOPARITY;      //  Parité = aucune
   dcb.StopBits = ONESTOPBIT;    //  stop bit

   fSuccess = SetCommState(hCom, &dcb); // configuration du port série selon la structure DCB

   if (!fSuccess)
   {
	  //  Handle the error.
	  printf ("SetCommState failed with error %d.", GetLastError());
      return (3);
   }

   //  Get the comm config again.
   fSuccess = GetCommState(hCom, &dcb);

   if (!fSuccess)
   {
      //  Handle the error.
	  printf ("GetCommState failed with error %d.", GetLastError());
	  return (2);
   }

   _tprintf (TEXT("Serial port %s successfully reconfigured."), pcCommPort);
   return (0);

}


//------------------------------------------------------------------------------------//


//Lecture du port série

void PortSerie::lireport()
{
	Vcontinue = false;
	isRead = false;
	do
	{
		isRead = ReadFile(hCom, &recvChar, 1, &read, NULL);

		if(ignoreData)
		{
			if(recvChar == '-')
			{
				ignoreData = false;
            }
        }

		if(!ignoreData)
		{
			recvBuf.push_back(recvChar);
			if (!isRead)
			{
				Vcontinue = false;
				break;
			}
		}
	} while (Vcontinue);
}
//------------------------------------------------------------------------------------//
// recuperer la donnée du buffer
std::deque<char> & PortSerie::getRecvBuf()
{
	return recvBuf;
}

//-------------------------------------------------------------------------------------//

//Ecriture sur le port Serie

void PortSerie::WriteFile()
{

char lpBuffer [] = "A";
DWORD dNoOFBytestoWrite ; // Nombre d'octets à écrire dans le port
DWORD dNoOfBytesWritten = 0; // Nombre d'octets écrits sur le port
dNoOFBytestoWrite = sizeof ( lpBuffer ) ;

Status = WriteFile ( hComm ,
lpBuffer, // Données à écrire sur le port
dNoOFBytestoWrite , // Nombre d'octets à écrire
& dNoOfBytesWritten , // Octets écrits
NULL ) ;
}

